.\" File automatically generated by doxy2man0.1
.\" Generation date: dim. sept. 7 2014
.TH rohc_comp_set_rtp_detection_cb 3 2014-09-07 "ROHC" "ROHC library Programmer's Manual"
.SH "NAME"
rohc_comp_set_rtp_detection_cb \- Set the RTP detection callback function.
.SH SYNOPSIS
.nf
.B #include <rohc/rohc_comp.h>
.sp
\fBbool rohc_comp_set_rtp_detection_cb\fP(
    \fBstruct rohc_comp *const        comp\fP,
    \fBrohc_rtp_detection_callback_t  callback\fP,
    \fBvoid *const                    rtp_private\fP
);
.fi
.SH DESCRIPTION
.PP 
Set or replace the callback function that the ROHC library will call to detect RTP streams among other UDP streams.
.PP 
The function is called once per UDP packet to compress, with the IP and UDP headers and the UDP payload. If the callback function returns true, the RTP profile is used for compression, otherwise the IP/UDP profile is used instead.
.PP 
Special value NULL may be used to disable the detection of RTP streams with the callback method. The detection will then be based on a list of UDP ports dedicated for RTP streams.
.SH PARAMETERS
.TP
.B comp
The ROHC compressor 
.TP
.B callback
The callback function used to detect RTP packets The callback is deactivated if NULL is given as parameter 
.TP
.B rtp_private
A pointer to an external memory area provided and used by the callback user 
.SH STRUCTURES
.SH RETURN VALUE
.PP
true on success, false otherwise
.SH EXAMPLE
.nf
/**
 * @brief The RTP detection callback which does detect RTP stream
 *
 * @param ip           The innermost IP packet
 * @param udp          The UDP header of the packet
 * @param payload      The UDP payload of the packet
 * @param payload_size The size of the UDP payload (in bytes)
 * @return             true if the packet is an RTP packet, false otherwise
 */
static bool rtp_detect(const unsigned char *const ip,
                       const unsigned char *const udp,
                       const unsigned char *const payload,
                       const unsigned int payload_size,
                       void *const rtp_private)
{
        uint16_t udp_dport;
        bool is_rtp;

        /* check UDP destination port */
        memcpy(&udp_dport, udp + 2, sizeof(uint16_t));
        if(ntohs(udp_dport) == 10042)
        {
                /* we think that the UDP packet is a RTP packet */
                fprintf(stderr, "RTP packet detected (expected UDP port)\n");
                is_rtp = true;
        }
        else
        {
                /* we think that the UDP packet is not a RTP packet */
                fprintf(stderr, "RTP packet not detected (wrong UDP port)\n");
                is_rtp = false;
        }

        return is_rtp;
}
        ...
        struct rohc_comp *compressor;           /* the ROHC compressor */
        ...
        compressor = rohc_comp_new2(ROHC_SMALL_CID, ROHC_SMALL_CID_MAX,
                                    gen_random_num, NULL);
        if(compressor == NULL)
        {
                fprintf(stderr, "failed create the ROHC compressor\n");
                goto error;
        }
        ...
        if(!rohc_comp_set_rtp_detection_cb(compressor, rtp_detect, NULL))
        {
                fprintf(stderr, "failed to set RTP detection callback\n");
                goto error;
        }
        ...
        rohc_comp_free(compressor);

 

.fi
.SH SEE ALSO
.BR rohc_comp.h (3),
.BR rohc_rtp_detection_callback_t (3),
.BR rohc_comp_add_rtp_port (3),
.BR rohc_comp_remove_rtp_port (3),
.BR rohc_comp_reset_rtp_ports (3)
